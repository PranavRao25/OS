Control registers:
1. ia - Instruction address register contains the address of the next instruction
2. psw - Program status word -
    a. 00 - System Mode / Masked interrupts
    b. 01 - System Mode / Enabled interrupts
    c. 10 - User Mode / Masked interrupts
    d. 11 - User Mode / Enabled interrupts
3. base - added to all addresses when in user mode
4. bound - upper address limit (else program error interrupt with ip=2), done before base added for user mode
5. iia - During an interrupt, Interrupt Instruction Address Register stores the value of ia register before an interrupt while ia will have address of interrupt handler. 
6. ipsw - During an interrupt, Interrupt Program Status Word stores the value of psw before an interrupt while psw loaded with 0
7. ip - Interrupt parameter register contains data about last interrupt
8. iva - Interrupt vector address register stores location of Interrupt Vector Table
9. timer - Interval timer register decrements once every microsec till reaches 0, when a timer interrupt is generated and storing 0 in this register clears any pending masked timer interrupts

System Mode - 
All addresses are physical
All instructions can be run
Interrupts can occur if psw[1] = 1

User Mode -
Logical addresses
Instructions forbidden to modify control registers (else cause program error interrupt ip=1)

Interrupts - immediate transfer of control caused by an event in the system

Example of Interrupts-
1. Program Error -
    a. ip=0 : undefined instruction
    b. ip=1 : illegal instruction in user mode
    c. ip=2 - address breached the bound

Interrupt handling by hardware -
1. psw -> ipsw
2. 0 -> psw
3. interrupt parameters -> ip
4. ia -> iia
5. 4 * (interrupt number) + iva = interrupt vector entry -> ia

Return for Interrupt (rti) -
1. iia -> ia
2. ipsw -> psw
3. normal execution

Masked Interrupts - recorded but not processes

System Call instruction generates an interrupt that causes the OS to gain control of the processor, instruction set of the OS virtual processor

System Calls-
1. Program executes system call instruction
2. ia -> iia & psw -> ipsw
3. 0 -> psw (system mode, interrupts disabled)
4. 1st instr of syscall interrupt handler (in syscall interrupt vector loc) -> ia
5. Syscall handler completes and executes rti (iia -> ia & ipsw -> psw)
6. Normal execution

File and I/O Syscalls - 
1. Open - Get ready to read/write a file (returns file pointer)
2. Create - create a new file and open it
3. Read - Read bytes from an open file
4. Write - write bytes to an open file
5. Lseek - change the location in the file of the next read/write
6. close - done reading/writing a file
7. unlink - remove file name from disk
8. stat - properties

Process Management System Calls -
1. CreateProcess - create a new process
2. Exit - terminate the process making the system call
3. Wait - wait for another process to Exit
4. Fork - create a child process
5. Execv - run a new process

Interprocess Communication System Calls -
1. CreateMessageQueue - create a queue to hold messages
2. SendMessage - send a message to the message queue
3. ReceiveMessage - receive a message to the message queue
4. DestroyMessageQueue - destroy a message queue

File & I/O Syscalls - 
1. open(filepath,flages) -> fid : creates open file connected to a file
    a. flag=0 -> reading
    b. flag=1 -> writing
    c. flag=2 -> read/write
2. creat(filepath,mode)-> fid : creates file and connects to open file
3. read(fid,buffer,count)->count : Reads bytes from open file
4. write(fid,buffer,count)->count : Write bytes to open file
5. lseek(fid,offset,mode) -> offset : Move position of next read/write
    a. moveMode=0 -> 0 as base (beginning)
    b. moveMode=1 -> current file location
    c. moveMode=2 -> current file size (ending)
6. close(fid)-> code : Disconnect open file from file
7. unlink(filepath)-> code : Delete the file

Files are just containers of data
Open Files are dynamic objects which allows byte read/writes into the file (an interface of the file)

Programs -
Static object that can exist in a file, and contains sequence f instructions

Process -
dynamic object with program instructions in execution, existing for a limited span of time
Each process has a save area where it saves its context (register values)

Differences between Pipes and Message Queues:
Pipes -
1. no fixed sized messages
2. created till the lifetime of the two processes, once closed cannot be opened
3. Connection between two processes (FIFO)
4. Can read data all at once

Message Queues:
1. Fixed size queues
2. stored in the RAM, can be closed and opened multiple times(more memory persistent)
3. No connection between two or more processes
4. Message Queues retrieves data individually

Message Queues use special identfiers rather than file descriptors, so don't rely on file I/O
Message queues do not garuantee FIFO, processes can specify the order
If a process requests data less than the Message Queue data size unit, it will receive nothing

A POSIX Message Queue is a prioirity queue
It is removed when all processes using it are closed
when receiving messages, msg_len must match the size of a message.

can be used only when used for writing

SOS

Simple OS has 2 major subsystems:
1. Process Management Subsystem
2. Disk Management Subsystem

Process Management Subsystem-
handles process abstraction
maintains process tables, creates message queues, system calls, dispatches processes to run on processor

Disk Management Subsystem-
handles disk abstraction
communicates with the disk hardware and handles disk interrupts
includes a disk driver which accopts disk operations and schedules them on the disk

Save Area -
Records hardware context of a process (contains all the registers)

Process Descriptor
Data structure which records the state of a process (register and process state) (slot allocated, time left till switch, state (Running, Ready, Blocked, Save Area

Interrupts-
1. System Calls
2. Timer
3. Disk
4. Program Error

Parallelism

Two Processors-
Private - Set of registers, Timer (call and receives its own interrupts)
Shared - Memory, Disk

* Issues with OS per processor-
(Each OS will have its own process table, memory segment)
1. Increased memory usage to store 2 OSes
2. Difficult Inter OS Process communication
3. Which controls the processor and disk of them (Master OS) ? *

SHARED OS - 
Only 1 OS Code
System Initialization done by only one processor (which initialises its data then starts the second processor)
Two processors run mutual exclusively at the same time
Each processor has its own
a. Set of registers
b. System Stack (better coordination)
c. current processes
d. Timer

Global Data -
a. Process Table (Not good for two individual process table as one may be full ready other not)
b. Disk Queue
c. Message Queues

Race Conditions -
Where two processes are interacting in some way, and the relative speed at which they run will affect the output

Atomic Action -
Non overlapping actions
Its intermediate state cannot be seen by any other processes
Ex - memory R/W

Exchangeword - 
To make reading old process state and writng the new value into an atomic action
Exchanges the values from a memory cell and hardware register (read from memory cell and write into it)
If two processors run ExchangeWord on same memory cell, then the cell will hold either of the values (the only way to do this both processes run non overlapping manner)
To gain access of the memory cell, a process calls the memory module over the system bus.
So the bus H/W unit fixes a processes as the bus master for some amount of cycles (1 cycle for read/write) and lets it run its atomic actions uninterrupted
This is used in the case of sharing Process Table (with the non-using one in a Busy Wait)

Process Table - 
Being a shared resource, we need to protect it from illegal accesses
To use it, a processor must check a ProcessTableFreeFlag whether the process table is in use or not
Given a processor is using the process table, it is given complete access and closes as per its need
The other processor will be in a Busy wait, continously checking the value of ProcessTableFreeFlag

Problem with Busy Wait is waste of time

Spin Lock - 
Variable protecting a shared resource and its state spinning (ExchangeWord) between itself and the processors
The ProcessTableFreeFlag above is a Spin Lock

Dispatcher -
We fix the process table to ourselves during its run

Message Queues -
Spin Lock - Key per Queue (Mutual Exclusion)
Once a processor receives a key, it can enter the room and access the Message Queues
The other process will spin the Key
After process 1 exits, the other enters

THREADS

Software Abstraction of Multiprocessor Computer
Lightweight Processes
Share memory and can run parallelly
More efficient,lighter and faster than processes (as no issues or delays with memory)
They don't use system calls to communicate, instead using memory
Provide parallellism in single process (Process parallellism is between two different processes)
Increases responsiveness 
Will have its own system stack and set of registers
Possible to have multiple threads to share the same code space

Each thread is executing a subset of the same instructions but in different execution (different contexts)
When a process is created, an initial thread is also created.
The process will exit only when last of its threads has exited (threads can exit any time)

Thread System Calls - 
1. CreateThread (startAddress, stackBegin) : thread_id -
	startAddress will give starting Address of execution
	stackBegin will have its stack beginning at this memory location
2. ExitThread (returnCode) -
	Exits the thread
	If last thread, calls ExitProcess and returns back to Wait syscall of Parent Process
	Else, returns back to parent Thread calling WaitThread
3. WaitThread (int thread_id) -
	Parent thread will wait for new thread

Process Table:
Each entry will have memory bounds and the head to the linked list of threads (no more process state)

Thread Table:
1. register save area
2. parent pid
3. thread state
4. pointer

The Dispatcher will run threads instead  of processes
No more ExitProcess (to exit a process we have to exit all of its threads)

User Threads
User process can have its own threads (and a scheduler to manage them)
More efficient than lightweight processes
Not recognised by the OS
If one user thread is blocked, the whole process blocks

Kernel Mode Processes -

OS Threads
In the simple implementation, we had made the OS wait for Message Queues, or Disk Queues.
This is done by saving the process context and blocking it
Better than this, we allow threads to run inside the OS Address Space, which will do all of the processing and interrupt handling.
Each Process is given its own Per-Process System stack which will store the context (save area) for each interrupt, and its kernel threads refer to the top of the stack (latest context)
Each new save area will be linked to the previous save area.
This speeds up the procedure.

Each process will a counter as inSystem which will count two things:
1. No of save areas stored in the system stack
2. No of threads?

SystemCall Interrupt Handler:
1. Save Area Updation -
	Each save area will have its first word as a pointer to the previous save area
	We will first acquire the memory chunk from the stack for the new save area
	If the process is entering into kernel mode for the first time, it will allocate the last (empty) slot in the linked list (stack)
	We store the registers, timeLeft and the pointer to the last save area in this space (as this save area forms the new top)
	(We are substracting the size of Savearea + 4 because it is a stack, so bottoms up)
	We increment the inSystem
2. Interrupt Running -
	Starts by loading 2 into psw register



